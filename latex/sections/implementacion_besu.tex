\section{Implementación en Besu}


El contrato inteligente fue desarrollado en Solidity\cite{SolidityDocs} y desplegado en una red Hyperledger 
Besu\cite{HyperledgerBesu} utilizando Remix IDE\cite{RemixIDE}. Esta sección describe la arquitectura del 
contrato, sus funciones principales y las consideraciones técnicas encontradas 
durante el despliegue (Apendice~\ref{app:despliegue_remix}).

\subsection{Arquitectura del contrato}

El contrato \texttt{\href{https://github.com/natar10/uva-ong-block/blob/main/backend/contracts/ContratoONG.sol}{ContratoONG.sol}} 
implementa un diseño modular, donde cada parte del 
contrato ( donación, compra del material, votaciones, ...) viene definida en un ''subcontrato'' 
diferente para una mejor organización.
De esta manera, en el contrato \texttt{ContratoONG.sol} únicamente se compila el resto de contratos, 
vinculados a éste por herencias con el siguiente orden:\\[6pt]

\textbf{OngBase → OngDonantes → OngProyectos → OngDonaciones → OngCompras → ContratoONG}\\

\textbf{\href{https://github.com/natar10/uva-ong-block/blob/main/backend/contracts/base/OngBase.sol}{OngBase:}} 
Define las estructuras de datos y mapeos básicos para donantes, proyectos, donaciones, compras y 
proveedores:

\begin{itemize}
    \item \textbf{Estructuras (Structs):}
    \begin{itemize}
        \item \texttt{Material}: almacena nombre y valor del material.
        \item \texttt{Donante}: almacena dirección, nombre, tipo de donante y total donado.
        \item \texttt{Proyecto}: contiene ID, descripción, responsable, cantidades recaudada y validada, estado, votos de aprobación y votos de cancelación.
        \item \texttt{Donacion}: registra ID, donante, proyecto, cantidad y timestamp.
        \item \texttt{Compra}: registra ID, comprador, proveedor, proyecto, cantidad, valor, tipo de material, fecha y estado de validación.
        \item \texttt{Proveedor}: almacena ID, descripción, dirección del proveedor y ganancias acumuladas.
        \item \texttt{TrazabilidadDonacion}: estructura auxiliar que agrupa una donación con su proyecto y compras asociadas.
    \end{itemize}

    \item \textbf{Enums:}
    \begin{itemize}
        \item \texttt{TipoDonante}: Individual, Empresa.
        \item \texttt{EstadoProyecto}: Propuesto, Activo, Cancelado.
    \end{itemize}

    \item \textbf{Mapeos (Mappings):}
    \begin{itemize}
        \item \texttt{mapping(address => Donante) donantes}
        \item \texttt{mapping(string => Proyecto) proyectos}
        \item \texttt{mapping(string => Donacion) donaciones}
        \item \texttt{mapping(string => Compra) compras}
        \item \texttt{mapping(address => Proveedor) proveedores}
        \item \texttt{mapping(string => mapping(address => bool)) donantesDeProyecto}
    \end{itemize}

    \item \textbf{Arrays para iteración:}
    \begin{itemize}
        \item \texttt{address[] listaDonantes}
        \item \texttt{string[] listaProyectos}
        \item \texttt{string[] listaDonaciones}
        \item \texttt{string[] listaCompras}
    \end{itemize}
\end{itemize}

Esta combinación de mappings para acceso directo y arrays para iteración permite tanto búsquedas eficientes como la capacidad de listar
todos los registros desde el frontend.

\subsection{Funciones principales}

El contrato dividilo en los módulos mecionados 
(\href{https://github.com/natar10/uva-ong-block/tree/main/backend/contracts/modules}{ver organización}) implementa 
las siguientes operaciones:

\subsubsection{Funciones de escritura}

\begin{itemize}
    \item \texttt{registrarDonante(string nombre, TipoDonante tipo)}: Permite a un usuario registrarse como donante. Verifica que no
    esté previamente registrado.

    \item \texttt{crearProyecto(string id, string descripcion, address responsable, EstadoProyecto estado)}: Función restringida al owner para crear nuevos
    proyectos. Valida que el ID no exista previamente y que el estado inicial no sea Cancelado.

    \item \texttt{donar(string proyectoId) payable}: Función principal que procesa donaciones. Recibe ETH, registra la donación,
    actualiza totales y asigna tokens de gobernanza (1 token por cada 0.001 ETH). Si el donante no está registrado, 
    lo crea automáticamente como individuo. Solo permite donar a proyectos en estado Activo.

    \item \texttt{votarAprobacion(string proyectoId, uint256 cantidadVotos)}: Permite a los donantes registrados 
    votar para aprobar un proyecto en estado Propuesto. Los tokens de gobernanza se queman al votar. Si se alcanza 
    el umbral de votos mínimos (VOTOS\_MINIMOS = 2), el proyecto pasa a estado Activo. Este umbral es debido a 
    propósitos demostrativos y debe ajustarse en implementaciones reales.

    \item \texttt{votarCancelacion(string proyectoId, uint256 cantidadVotos)}: Permite votar para cancelar un proyecto. Para proyectos Activos, solo pueden votar quienes hayan donado a ese proyecto. Los tokens se queman al votar. Si se alcanza el umbral, el proyecto se cancela.

    \item \texttt{validarFondosProyecto(string proyectoId, uint256 cantidad)}: Función administrativa (solo owner) para marcar fondos como validados.

    \item \texttt{registrarProveedor(address proveedor, string nombre, string descripcion)}: Función restringida al owner para registrar proveedores autorizados.

    \item \texttt{realizarCompra(string compraId, string proyectoId, address proveedor,\\ 
    string tipoMaterial, uint128 cantidad)}: Permite al responsable del proyecto realizar \\ compras. Verifica fondos suficientes y reserva el monto del balance del proyecto.

    \item \texttt{validarCompra(string compraId)}: El responsable del proyecto valida una compra después de verificar la recepción física del material. Al validar, se transfiere el ETH al proveedor (actúa como ``oráculo humano'').
\end{itemize}

\subsubsection{Funciones de lectura}

El contrato incluye funciones de consulta que no modifican el estado:

\begin{itemize}
    \item \texttt{obtenerDonante(address)}, \texttt{obtenerProyecto(string)}, \texttt{obtenerDonacion(string)}, \\ \texttt{obtenerCompra(string)}
    \item \texttt{obtenerTotalDonantes()}, \texttt{obtenerTotalProyectos()}, \texttt{obtenerTotalDonaciones()}
    \item \texttt{obtenerTokensGobernanza(address)}: retorna el balance de tokens de gobernanza de un donante
    \item \texttt{obtenerComprasPorProyecto(string proyectoId)}: retorna todas las compras asociadas a un proyecto
    \item \texttt{obtenerTrazabilidadDonante(address donante)}: retorna la trazabilidad completa de un donante, incluyendo sus donaciones, proyectos asociados y compras realizadas
    \item \texttt{getMaterialByName(string nombre)}: obtiene la información de un material por su nombre
    \item \texttt{obtenerBalance()}: retorna el balance de ETH del contrato
\end{itemize}

\subsection{Control de acceso}

Se implementa un sistema de permisos básico mediante el modificador \texttt{soloOwner}, que restringe funciones críticas al propietario del contrato:

\begin{lstlisting}[language=Solidity]
modifier soloOwner() {
    require(msg.sender == owner,
            "Solo el owner puede ejecutar esto");
    _;
}
\end{lstlisting}

El owner se establece en el constructor como la dirección que despliega el contrato. 
También cada función tiene sus validaciones y restricciones específicas según la acción que 
realiza. 
Por ejemplo, solo los donantes registrados pueden votar, y solo el responsable del 
proyecto puede realizar compras.

\subsection{Token de Gobernanza}

El sistema incluye un contrato separado 
\texttt{\href{https://github.com/natar10/uva-ong-block/blob/main/backend/contracts/TokenGobernanza.sol}{TokenGobernanza.sol}} 
que implementa un token ERC20 para la gobernanza de la ONG. Este token permite a los 
donantes participar en las votaciones de proyectos (Ver apendice~\ref{app:token_gobernanza}).

\begin{itemize}
    \item \textbf{Estándar}: ERC20 con nombre ``Token Gobernanza ONG'' y símbolo ``TKN4GOOD''
    \item \textbf{Emisión}: Los tokens se mintean automáticamente al realizar donaciones (1 token por cada 0.001 ETH)
    \item \textbf{Consumo}: Los tokens se queman al votar, implementando un sistema de votación con peso económico
    \item \textbf{Control de acceso}: Solo el contrato de donaciones (ContratoONG) mintear y quemar tokens
\end{itemize}

El token utiliza las librerías de OpenZeppelin para garantizar la seguridad y el cumplimiento del estándar ERC20.

\subsection{Eventos}

Para facilitar la integración con el frontend y permitir el seguimiento de operaciones, se definieron los siguientes eventos:

\begin{itemize}
    \item \texttt{DonacionRealizada(address indexed donante, string proyectoId, uint256 cantidad)}
    \item \texttt{ProyectoCreado(string id, string descripcion)}
    \item \texttt{DonanteRegistrado(address indexed direccion, string nombre)}
    \item \texttt{ProyectoAprobado(string id, uint256 votosTotal)}
    \item \texttt{ProyectoCancelado(string id, uint256 votosTotal, uint256 fondosAlFondoComun)}
    \item \texttt{VotoAprobacion(address indexed votante, string proyectoId, uint256 cantidadVotos)}
    \item \texttt{VotoCancelacion(address indexed votante, string proyectoId, uint256 cantidadVotos)}
    \item \texttt{CompraRealizada(address indexed comprador, string compraId, uint256 valor)}
    \item \texttt{CompraValidada(string compraId, address indexed validador, address indexed proveedor, uint256 valor)}
    \item \texttt{TokenGobernanzaActualizado(address indexed tokenAnterior, address indexed tokenNuevo)}
\end{itemize}

\subsection{Proceso de despliegue}

El contrato fue desplegado utilizando Remix IDE conectado a la red BLOCK LAB de Besu. 
El proceso incluyó (Ver apéndice ~\ref{app:despliegue_remix}):

\begin{enumerate}
    \item Compilación del contrato con Solidity 0.8.0.
    \item Conexión de MetaMask\cite{MetaMask} a la red BLOCK LAB.
    \item Configuración de permisos de dominio en MetaMask.
    \item Despliegue mediante Remix utilizando el injected provider y london.
    \item Obtención de la dirección del contrato desplegado.
\end{enumerate}

\subsection{Consideraciones técnicas importantes}

Durante la implementación y despliegue se identificaron varios aspectos críticos:

\begin{itemize}
    \item \textbf{Permisos de red en MetaMask:} Es fundamental configurar correctamente los permisos para el dominio específico en MetaMask, asegurando que la extensión utilice la red BLOCK LAB. Sin esta configuración, suelen aparecer problemas de conexión.

    \item \textbf{Inmutabilidad de contratos:} Los contratos en blockchain no son editables una vez desplegados. Cualquier modificación requiere desplegar un nuevo contrato con una nueva dirección, lo que implica actualizar la configuración en el frontend.

    \item \textbf{Coordinación frontend-contrato:} La dirección del contrato debe actualizarse manualmente en el archivo de configuración del frontend cada vez que se despliega una nueva versión, usando para ello el archivo ABI generado al desplegar el contrato.

    \item \textbf{Gas y costos:} Aunque Besu no requiere ETH real, se debe tener en cuenta el concepto de gas para futuras implementaciones en redes públicas.
\end{itemize}
