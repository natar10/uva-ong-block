\section{Implementación del front end}

Se desarrolló una aplicación web utilizando React con TypeScript y Vite como herramienta de construcción. El frontend se conecta al contrato inteligente mediante la biblioteca ethers.js y MetaMask, permitiendo a los usuarios interactuar con la blockchain de forma intuitiva.

\subsection{Tecnologías utilizadas}

\begin{itemize}
    \item \textbf{React 19:} Framework principal para la interfaz de usuario
    \item \textbf{TypeScript:} Para tipado estático y mayor seguridad en el desarrollo
    \item \textbf{Vite:} Herramienta de construcción moderna y rápida
    \item \textbf{Material-UI (MUI):} Biblioteca de componentes para una interfaz profesional
    \item \textbf{TanStack Router:} Gestión de rutas y navegación
    \item \textbf{TanStack Query:} Manejo de estado y cache de datos blockchain
    \item \textbf{ethers.js:} Librería para interactuar con Ethereum/Besu
    \item \textbf{MetaMask:} Extensión de navegador para gestión de billeteras
\end{itemize}

\subsection{Arquitectura del frontend}

La aplicación se estructura en capas separando responsabilidades:

\subsubsection{Hooks personalizados}

Se crearon hooks de React para encapsular la lógica de interacción con el contrato:

\begin{itemize}
    \item \texttt{useContract}: Hook base que inicializa la conexión con el contrato utilizando el ABI y la dirección configurada
    \item \texttt{useProyectos}: Obtiene la lista de proyectos activos
    \item \texttt{useDonaciones}: Consulta el historial de donaciones
    \item \texttt{useDonante}: Recupera información del donante conectado
    \item \texttt{useRealizarDonacion}: Gestiona el proceso de realizar una donación
    \item \texttt{useRegistrarDonante}: Maneja el registro de nuevos donantes
\end{itemize}

\subsubsection{Capa de datos}

Se implementó una arquitectura basada en queries y mutations siguiendo el patrón de TanStack Query:

\begin{itemize}
    \item \textbf{Queries} (\texttt{data/query}): Funciones de solo lectura que consultan el estado del contrato
    \item \textbf{Mutations} (\texttt{data/mutations}): Operaciones que modifican el estado (donaciones, registros, votaciones)
\end{itemize}

\subsubsection{Configuración del contrato}

El archivo \texttt{contractConfig.ts} centraliza la configuración:

\begin{itemize}
    \item Dirección del contrato desplegado
    \item ABI del contrato (importado desde el JSON generado por Remix)
    \item Parámetros de conexión a la red
\end{itemize}

\subsection{Funcionalidades implementadas}

La aplicación permite a los usuarios:

\begin{enumerate}
    \item \textbf{Conectar billetera:} Mediante MetaMask, conectándose automáticamente a la red BLOCK LAB
    \item \textbf{Visualizar proyectos:} Lista de proyectos activos con su información detallada
    \item \textbf{Realizar donaciones:} Seleccionar un proyecto y enviar ETH
    \item \textbf{Consultar historial:} Ver todas las donaciones realizadas
    \item \textbf{Votar proyectos:} Utilizar tokens de gobernanza para votar
    \item \textbf{Registrarse como donante:} Crear un perfil en el sistema
\end{enumerate}

\subsection{Integración con MetaMask}

La conexión con MetaMask fue un aspecto crítico de la implementación. Se identificaron y resolvieron varios desafíos:

\subsubsection{Consideraciones importantes}

\begin{itemize}
    \item \textbf{Permisos de dominio:} MetaMask debe tener permisos correctamente configurados para el dominio (tanto en desarrollo local como en producción). Sin los permisos adecuados para usar la red BLOCK LAB, aparecen errores de conexión.

    \item \textbf{Conexión automática:} MetaMask se conecta automáticamente tanto en desarrollo local (localhost) como en el servidor desplegado en Vercel. Lo esencial es configurar los permisos de red correctamente.

    \item \textbf{Verificación de red:} El frontend verifica que el usuario esté conectado a la red BLOCK LAB antes de permitir transacciones.

    \item \textbf{Reconocimiento de billetera:} Una vez configurados los permisos, MetaMask reconoce inmediatamente la billetera conectada.
\end{itemize}

\subsection{Manejo de transacciones}

Un aspecto fundamental del diseño es el manejo correcto de las interacciones con la blockchain:

\begin{itemize}
    \item \textbf{Transacciones de solo lectura:} Las consultas (queries) se ejecutan sin necesidad de conexión de billetera, permitiendo ver información pública antes de conectarse.

    \item \textbf{Transacciones de escritura:} Operaciones como donaciones y votaciones requieren que el usuario conecte su billetera y firme la transacción.

    \item \textbf{Feedback al usuario:} Se implementaron estados de carga y mensajes de error para informar sobre el progreso de las transacciones.

    \item \textbf{Actualización de estado:} Tras completar una transacción, se invalidan y refrescan automáticamente las queries afectadas.
\end{itemize}

\subsection{Diseño de interfaz}

La aplicación utiliza Material-UI para proporcionar una experiencia de usuario moderna:

\begin{itemize}
    \item Dashboard con estadísticas de donaciones
    \item Cards visuales para cada proyecto con imágenes
    \item Formularios intuitivos para donaciones y registro
    \item Tablas con el historial completo de transacciones
    \item Modo claro/oscuro adaptativo
\end{itemize}

\subsection{Despliegue}

El frontend fue desplegado en Vercel, lo que permite:

\begin{itemize}
    \item Acceso público a la aplicación
    \item Despliegue continuo desde el repositorio
    \item HTTPS automático
    \item Integración con MetaMask en entorno de producción
\end{itemize}

\subsection{Lecciones aprendidas}

Durante el desarrollo del frontend se identificaron varios aspectos críticos:

\begin{enumerate}
    \item \textbf{Blockchain como backend:} Al utilizar blockchain como capa de persistencia, todas las operaciones de lectura deben ejecutarse antes de requerir la conexión de billetera. Esto permite mostrar información al usuario y verificar que está en la red correcta antes de solicitar permisos.

    \item \textbf{Actualización de direcciones:} Cada vez que se despliega un nuevo contrato, es necesario actualizar manualmente la dirección en \texttt{contractConfig.ts}. Este proceso es inevitable debido a la inmutabilidad de los contratos.

    \item \textbf{Gestión de estado asíncrono:} Las interacciones con blockchain son inherentemente asíncronas y pueden fallar. TanStack Query facilita el manejo de estos estados (loading, error, success).

    \item \textbf{Testing con cuentas de desarrollo:} Es fundamental tener múltiples cuentas de MetaMask configuradas para probar diferentes roles (owner, donantes, etc.).
\end{enumerate}
